i =1;
i = i+1;

cpu1 -> main memory ->cache i+1 ->cache(2) -> main memory(2)

cpu2 -> main memory ->cache i+1 ->cache(2) -> main memory(2)

并发操作，内存可见性问题：
1. 给数据总线加锁
    总线（数据总线、地址中心、控制总线）
    串行化
2. CPU高速缓存一致性协议     
核心思想：   
* 当cpu写入数据的时候，如果发现该数据被共享（在其他cpu中也存在该变量的副本），会发出一个信号，通知
其他cpu该变量的缓存无效
* 当其他cpu访问变量的时候，重新到主内存获取

并发编程中三个重要概念：
1. 原子性  
   一个操作或多个操作，要么都成功，要么都失败，中间不能由于任何因素中断
   对基本数据类型的变量的读取和赋值是保证了原子性
   a = 10; 原子性  
   b = a;  不满足  1.read a 2.assign b
   c++;     不满足
2. 可见性
3. 有序性  
int i = 0;  
boolean flag = false;   
i = 1;  
flag = true;

重排序只要求最终一致性 
* 3.1 代码执行顺序，编写在前面的发生在编写后面（单线程最终一致性，多线程不能保证）
* 3.2 unlock必须发生在lock之后
* 3.3 volatile修饰的变量，对于一个变量的写操作先于对该变量的读操作
* 3.4 传递规则，A先于B，B先于C，那么A先于C
* 3.5 线程启动规则，start方法先于线程run方法
* 3.6 线程中断规则，interrupt这个动作，必须发生在捕获这个动作之前
* 3.7 对象的销毁规则，初始化必须发生在finalize之前
* 3.8 线程的终结规则，所有操作必须发生在线程死亡之前

### volatile关键字
一旦一个共享变量被volatile修饰，具有两层语义：
1. 保证了不同线程之间的可见性
2. 禁止对其进行重排序，也就是保证了有序性
3. 并未保证原子性